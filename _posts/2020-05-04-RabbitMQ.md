# RabbitMQ

<!--  https://www.jianshu.com/p/0d400d30936b -->

## 1、简介

```
RabbitMQ是由Erlang语言编写的实现了高级消息队列协议（AMQP）的开源消息代理软件（也可称为 面向消息的中间件）
```

## 2、工作模式

```
 1、工作队列模式(Work Queue)
 2、分发模式(Fanout Exchange)
 3、通配符模式（Topic Exchange）
```

## 3、个体介绍

### 		1、工作队列模式

<!-- -->

```
避免立即做一个资源密集型任务，必须等待它完成，而是把这个任务安排到稍后再做。我们将任务封装为消息并将其发送给队列。后台运行的工作进程将弹出任务并最终执行作业。当有多个worker同时运行时，任务将在它们之间共享。
```

### 		2、分发模式

<!-- 一个消息多个消费 队列和交换机绑定 -->

```
一个生产者，多个消费者，每一个消费者都有自己的一个队列，生产者没有将消息直接发送到队列，而是发送到了交换机，每个队列绑定交换机，生产者发送的消息经过交换机，到达队列，实现一个消息被多个消费者获取的目的。需要注意的是，如果将消息发送到一个没有队列绑定的exchange上面，那么该消息将会丢失，这是因为在rabbitMQ中exchange不具备存储消息的能力，只有队列具备存储消息的能力。
```

### 		3、通配符模式

<!-- 匹配对应的队列 -->

```
这种模式添加了一个路由键，生产者发布消息的时候添加路由键，消费者绑定队列到交换机时添加键值，这样就可以接收到需要接收的消息。
符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词
```

## 4、使用

### 		1、安装

​					1、docker安装

​					2、本地安装 

### 		2、配置

```
#pom文件添加依赖

<dependency>   	   		<groupId>org.springframework.boot</groupId>
 <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```

```
# rabbitmq配置

spring:
    rabbitmq:
      addresses: 127.0.0.1
      username: guest
      password: guest:
```

## 5、代码

###  1、工作队列模式

​		1、创建一个队列

​		2、队列生产消息



​		1、 接收消息 处理

###  2、分发模式

​		1、创建多个队列

​		2、创建一个交换机

​		3、交换机 和 多个队列绑定

​		4、向交换机发送消息

​		

​		1、接收队列消息

###  3、通配符模式

​		1、创建多个队列

​		2、创建一个交换机

​		3、交换机 和 多个队列绑定 【绑定对应的key】

<!--“#”匹配一个或多个词，“*”匹配不多不少一个词-->

​		4、向交换机发送消息



​		1、接收队列消息【匹配对应的key消息】

## 6、实现原理

 ![img](https://pic002.cnblogs.com/images/2012/444975/2012102817293188.png) 

 AMQP当中有四个概念非常重要: 虚拟主机（virtual host），交换机（exchange），队列（queue）和绑定（binding）。一个虚拟主机持有一组交换机、队列和绑定。 

## 7、面试题

### 1、使用rabbitMQ的好处

#### 1、解耦

可以直接在a项目里面调用b项目的实现

#### 2、异步

不必要的操作以异步的方式进行，增加响应速度

#### 3、 削峰 

缓解并发量大的时候 直接 怼到数据库

### 2、channel、exchange 和 queue 是逻辑概念，还是对应着进程实体？分别起什么作用？

 exchange 内部实现为保存 binding 关系的查找表；

channel 是实际进行路由工作的实体，即负责按照 routing_key 将 message 投递给 queue 。 

### 3、消息基于什么传输的

由于tcp的连接销毁开销很大，并且并发数受到系统的限制，会造成性能瓶颈。所以rabbitMQ是使用信道方式来传输数据，信道是建立在真实的tcp的连接内的虚拟连接

### 4、消息是如何分发的

如果有人订阅该队列，会以循环的方式发送给消费者。

### 5、使用缺点

1、系统复杂性增加

2、系统可用性降低（比如rabbitMQ挂掉了，服务就可能出现问题）

### 6、死性队列和延迟队列

#### 1、死性队列

1. 消息被拒绝（Basic.Reject或Basic.Nack）并且设置 requeue 参数的值为 false
2. 消息过期了
3. 队列达到最大的长度



**过期消息设置**

<!-- 如果在只定的时间没被处理那么该消息就会成为死性消息-->

1、可以对队列本身进行设置

2、可以对消息进行设置

  **队列设置：**在队列申明的时候使用 x-message-ttl 参数，单位为 毫秒

  **单个消息设置：**是设置消息属性的 expiration 参数的值，单位为 毫秒



#### 2、延迟队列

 **延时队列：**在rabbitmq中不存在延时队列，但是我们可以通过设置消息的过期时间和死信队列来模拟出延时队列。消费者监听死信交换器绑定的队列，而不要监听消息发送的队列。 



### 7、如何解决消息丢失的问题

####  1、生产者丢数据

 RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。 

####  2、队列丢失数据

 一般是开启持久化磁盘的配置。 

①、将queue的持久化标识durable设置为true,则代表是一个持久的队列

②、发送消息的时候将deliveryMode=2

####  3、消费者丢失数据

 启用手动确认模式可以解决这个问题 

### 8、如何避免消息重复发送

1、在消息生产时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重和幂等的依据（消息投递失败并重传），避免重复的消息进入队列

2、在消息消费时，要求消息体中必须要有一个bizId（对于同一业务全局唯一，如支付ID、订单ID、帖子ID等）作为去重和幂等的依据，避免同一条消息被重复消费。

### 9、如何确保消息接收方消费了消息？

 接收方消息确认机制：消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ才能安全地把消息从队列中删除。 

### 10、如何确保消息正确地发送至RabbitMQ？

 RabbitMQ使用发送方确认模式，确保消息正确地发送到RabbitMQ。发送方确认模式：将信道设置成confirm模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID。 

### 11、消息是如何路由的

1、消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。

2、通过队列路由键，可以把队列绑定到交换器上。

3、消息到达交换器后，RabbitMQ会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）。如果能够匹配到队列，则消息会投递到相应队列中；如果不能匹配到任何队列，消息将进入 “黑洞”。
